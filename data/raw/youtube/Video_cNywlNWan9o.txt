Source: https://www.youtube.com/watch?v=cNywlNWan9o
Channel: Fireship

ISO/IEC9899 is arguably the most important document in the history of humankind. More significant than the Magna Carta has built more wealth than Satoshi's Bitcoin white paper and is even more sacred than the moon landing telemetry data which was lost by NASA. This document is the official spec for the C programming language. the mother of almost all modern languages like C++, Java, JavaScript, Python, and is also the foundation for operating systems, compilers, encryption tools, game engines, and smart toilets. It's a simple, humble language that built the world, but sometimes it also likes to destroy the world. In today's video, we'll look at five simple code examples of memory management in C. The five code examples that go hard, the code that's cost companies billions of dollars and put programmers in jail. But you might be saying to yourself, "Wait a minute, I'm just a soy dev who relies on garbage collection, and this is above my pay grade." Well, actually, memory management in C is something you can learn in 30 seconds. The C forces you to grow up and manage memory by yourself. That means if you want to put some data into the computer's RAM, you allocate some bytes with the Malik function. It returns a memory address that looks like this, which you can then access in your code using a pointer, which itself is just a variable that points to a memory address. And now we can start putting crap in it. But every Malik also needs a free, which will release the memory when you're done with it. That's pretty much all there is to it, and it didn't even take 30 seconds to master it. But with great power comes a million different ways to shoot yourself in the foot, like don't call free twice, never use freed memory, don't call free after midnight, and definitely don't forget to do bounds checking. One of the first large- scale attacks on the internet was the Morris worm. In 1988, it took out about 6,000 machines, which at the time was 10% of the internet. And it was able to do that because libraries like Fingered and Sendmail had code that looks similar to this. Here we have a buffer with 512 bytes. Then we put some data into it. But the problem is we're not checking the size, which could result in a buffer overflow. This allowed the worm to overwrite return addresses on the stack, allowing for arbitrary code execution. That's because C doesn't automatically perform bounds checking. And if you try to do something like access an array out of bounds, it leads to undefined behavior. But this can be fixed in a variety of ways with the most simple approach being a conditional statement that the creator of the Morris worm almost ended up in prison, but it's nowhere near as bad as heartbleleed in 2014. OpenSSL used an extension called heartbeat, which was designed to keep a connection between a client and server alive. What's supposed to happen on a normal heartbeat is the client sends a message like I'm sending five bytes with the message hello. Then the server will echo back hello. It's simple enough, but it was missing one thing. The code didn't actually verify that the number of bytes matched the actual length of the value. That allowed attackers to send a malicious heartbeat where the client would say, "I'm sending 64,000 bytes with a value of hello." Then the server would copy back all those 64,000 bytes which could contain sensitive information like private encryption keys, passwords, and so on. And because this bug occurred on OpenSSL, which is encryption software that powers millions of websites, if fixing it became a massive disaster. But another way to mess up CC code is to use memory after it's been freed. And that's exactly what happened to Internet Explorer in 2013. The CC code looks like this, where you allocate some memory, but free it, and then try to use it again somewhere later in the code. In this case, the code lived in Internet Explorer 8 and was meant to free up memory when JavaScript code would remove elements from an HTML page. However, the pointer to the freed object still exists in Internet Explorer's internal structure, and that allowed attackers to set up malicious websites that could take control of your system by doing nothing more than visiting a website. That's not good. But when working with C, it's also important to know how to count properly because being off by one can lead to catastrophic results. In this code example, we're using a function from the C standard library to append some values to a string. But because we didn't take into account a null terminating character, we're going to get yet another buffer overflow. And finally, that brings us to double free. In this code here, you'll notice that we're freeing the same memory twice in two different parts of the program. The freeing memory twice may not sound like a big deal, but it leads to undefined behavior, at which point your code sucks and all bets are off. Your program might work fine, it might crash, or it could allow an attacker to write arbitrary values in memory. As you can see, C can be dangerous, but it's the foundation for all sorts of amazing software like everybody's favorite SQL database, Postgress. And that's why you need to know about Gel, the sponsor of today's video, a next-gen Postgress database platform that lets you model your data with simple types instead of tables. Not only is it more natural to work with, but it also provides total type safety, graph-like modeling, and painless schema migrations. Gel's type safe query builder gives you all the power of SQL but with modern tooling that makes it feel like you're programming in 2025, not 2005. You can use their Next.js starter template like I'm doing here to get up and running in just a few minutes and you can use their built-in O and AI solutions to add more advanced features over time to try out gel with the link below to get started today. Thanks for watching and I will see you in the next 